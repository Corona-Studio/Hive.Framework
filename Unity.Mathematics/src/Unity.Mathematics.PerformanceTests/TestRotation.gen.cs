//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated. To update the generation of this file, modify and re-run Unity.Mathematics.CodeGen.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using NUnit.Framework;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.PerformanceTesting;
using Unity.Mathematics.Geometry;
using Unity.Burst;

namespace Unity.Mathematics.PerformanceTests
{
    partial class TestRotation
    {
        [BurstCompile(CompileSynchronously = true)]
        public unsafe class float4x4_EulerXYZ
        {
            public const int iterations = 10000;

            public struct Arguments : IDisposable
            {
                public Random rng;
                public float3* v;
                public float4x4* m;

                public void Init()
                {
                    rng = new Random(1);
                    v = (float3*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<float3>() * iterations, UnsafeUtility.AlignOf<float3>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        v[i] = new float3(1.0f);
                    }

                    m = (float4x4*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<float4x4>() * iterations, UnsafeUtility.AlignOf<float4x4>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        m[i] = float4x4.identity;
                    }

                }

                public void Dispose()
                {
                    UnsafeUtility.Free(v, Allocator.Persistent);
                    UnsafeUtility.Free(m, Allocator.Persistent);
                }
            }

            public static void CommonTestFunction(ref Arguments args)
            {
                for (int i = 0; i < iterations; ++i)
                {
                    args.m[i] = float4x4.EulerXYZ(args.v[i]);
                }
            }

            public static void MonoTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            [BurstCompile(CompileSynchronously = true)]
            public static void BurstTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            public delegate void TestFunction(ref Arguments args);
        }

        [Test, Performance]
        public void float4x4_EulerXYZ_mono()
        {
            float4x4_EulerXYZ.TestFunction testFunction = float4x4_EulerXYZ.MonoTestFunction;
            var args = new float4x4_EulerXYZ.Arguments();
            args.Init();

            var monoSampleGroup = new SampleGroup("Mono", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(monoSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }

        [Test, Performance]
        public void float4x4_EulerXYZ_burst()
        {
            FunctionPointer<float4x4_EulerXYZ.TestFunction> testFunction = BurstCompiler.CompileFunctionPointer<float4x4_EulerXYZ.TestFunction>(float4x4_EulerXYZ.BurstTestFunction);
            var args = new float4x4_EulerXYZ.Arguments();
            args.Init();

            var burstSampleGroup = new SampleGroup("Burst", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(burstSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }
        [BurstCompile(CompileSynchronously = true)]
        public unsafe class float3x3_EulerXYZ
        {
            public const int iterations = 10000;

            public struct Arguments : IDisposable
            {
                public Random rng;
                public float3* v;
                public float3x3* m;

                public void Init()
                {
                    rng = new Random(1);
                    v = (float3*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<float3>() * iterations, UnsafeUtility.AlignOf<float3>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        v[i] = new float3(1.0f);
                    }

                    m = (float3x3*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<float3x3>() * iterations, UnsafeUtility.AlignOf<float3x3>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        m[i] = float3x3.identity;
                    }

                }

                public void Dispose()
                {
                    UnsafeUtility.Free(v, Allocator.Persistent);
                    UnsafeUtility.Free(m, Allocator.Persistent);
                }
            }

            public static void CommonTestFunction(ref Arguments args)
            {
                for (int i = 0; i < iterations; ++i)
                {
                    args.m[i] = float3x3.EulerXYZ(args.v[i]);
                }
            }

            public static void MonoTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            [BurstCompile(CompileSynchronously = true)]
            public static void BurstTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            public delegate void TestFunction(ref Arguments args);
        }

        [Test, Performance]
        public void float3x3_EulerXYZ_mono()
        {
            float3x3_EulerXYZ.TestFunction testFunction = float3x3_EulerXYZ.MonoTestFunction;
            var args = new float3x3_EulerXYZ.Arguments();
            args.Init();

            var monoSampleGroup = new SampleGroup("Mono", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(monoSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }

        [Test, Performance]
        public void float3x3_EulerXYZ_burst()
        {
            FunctionPointer<float3x3_EulerXYZ.TestFunction> testFunction = BurstCompiler.CompileFunctionPointer<float3x3_EulerXYZ.TestFunction>(float3x3_EulerXYZ.BurstTestFunction);
            var args = new float3x3_EulerXYZ.Arguments();
            args.Init();

            var burstSampleGroup = new SampleGroup("Burst", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(burstSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }
        [BurstCompile(CompileSynchronously = true)]
        public unsafe class float4x4_AxisAngle
        {
            public const int iterations = 10000;

            public struct Arguments : IDisposable
            {
                public Random rng;
                public float3* v;
                public float4x4* m;
                public float* angle;

                public void Init()
                {
                    rng = new Random(1);
                    v = (float3*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<float3>() * iterations, UnsafeUtility.AlignOf<float3>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        v[i] = math.normalize(new float3(1.0f));
                    }

                    m = (float4x4*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<float4x4>() * iterations, UnsafeUtility.AlignOf<float4x4>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        m[i] = float4x4.identity;
                    }

                    angle = (float*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<float>() * iterations, UnsafeUtility.AlignOf<float>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        angle[i] = 1.0f;
                    }

                }

                public void Dispose()
                {
                    UnsafeUtility.Free(v, Allocator.Persistent);
                    UnsafeUtility.Free(m, Allocator.Persistent);
                    UnsafeUtility.Free(angle, Allocator.Persistent);
                }
            }

            public static void CommonTestFunction(ref Arguments args)
            {
                for (int i = 0; i < iterations; ++i)
                {
                    args.m[i] = float4x4.AxisAngle(args.v[i], args.angle[i]);
                }
            }

            public static void MonoTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            [BurstCompile(CompileSynchronously = true)]
            public static void BurstTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            public delegate void TestFunction(ref Arguments args);
        }

        [Test, Performance]
        public void float4x4_AxisAngle_mono()
        {
            float4x4_AxisAngle.TestFunction testFunction = float4x4_AxisAngle.MonoTestFunction;
            var args = new float4x4_AxisAngle.Arguments();
            args.Init();

            var monoSampleGroup = new SampleGroup("Mono", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(monoSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }

        [Test, Performance]
        public void float4x4_AxisAngle_burst()
        {
            FunctionPointer<float4x4_AxisAngle.TestFunction> testFunction = BurstCompiler.CompileFunctionPointer<float4x4_AxisAngle.TestFunction>(float4x4_AxisAngle.BurstTestFunction);
            var args = new float4x4_AxisAngle.Arguments();
            args.Init();

            var burstSampleGroup = new SampleGroup("Burst", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(burstSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }
        [BurstCompile(CompileSynchronously = true)]
        public unsafe class float3x3_AxisAngle
        {
            public const int iterations = 10000;

            public struct Arguments : IDisposable
            {
                public Random rng;
                public float3* v;
                public float3x3* m;
                public float* angle;

                public void Init()
                {
                    rng = new Random(1);
                    v = (float3*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<float3>() * iterations, UnsafeUtility.AlignOf<float3>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        v[i] = math.normalize(new float3(1.0f));
                    }

                    m = (float3x3*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<float3x3>() * iterations, UnsafeUtility.AlignOf<float3x3>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        m[i] = float3x3.identity;
                    }

                    angle = (float*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<float>() * iterations, UnsafeUtility.AlignOf<float>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        angle[i] = 1.0f;
                    }

                }

                public void Dispose()
                {
                    UnsafeUtility.Free(v, Allocator.Persistent);
                    UnsafeUtility.Free(m, Allocator.Persistent);
                    UnsafeUtility.Free(angle, Allocator.Persistent);
                }
            }

            public static void CommonTestFunction(ref Arguments args)
            {
                for (int i = 0; i < iterations; ++i)
                {
                    args.m[i] = float3x3.AxisAngle(args.v[i], args.angle[i]);
                }
            }

            public static void MonoTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            [BurstCompile(CompileSynchronously = true)]
            public static void BurstTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            public delegate void TestFunction(ref Arguments args);
        }

        [Test, Performance]
        public void float3x3_AxisAngle_mono()
        {
            float3x3_AxisAngle.TestFunction testFunction = float3x3_AxisAngle.MonoTestFunction;
            var args = new float3x3_AxisAngle.Arguments();
            args.Init();

            var monoSampleGroup = new SampleGroup("Mono", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(monoSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }

        [Test, Performance]
        public void float3x3_AxisAngle_burst()
        {
            FunctionPointer<float3x3_AxisAngle.TestFunction> testFunction = BurstCompiler.CompileFunctionPointer<float3x3_AxisAngle.TestFunction>(float3x3_AxisAngle.BurstTestFunction);
            var args = new float3x3_AxisAngle.Arguments();
            args.Init();

            var burstSampleGroup = new SampleGroup("Burst", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(burstSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }
        [BurstCompile(CompileSynchronously = true)]
        public unsafe class float3x3_LookRotation
        {
            public const int iterations = 10000;

            public struct Arguments : IDisposable
            {
                public Random rng;
                public float3* forward;
                public float3* up;
                public float3x3* m;

                public void Init()
                {
                    rng = new Random(1);
                    forward = (float3*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<float3>() * iterations, UnsafeUtility.AlignOf<float3>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        forward[i] = math.normalize(new float3(1.0f));
                    }

                    up = (float3*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<float3>() * iterations, UnsafeUtility.AlignOf<float3>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        up[i] = math.normalize(new float3(0.0f, 1.0f, 0.0f));
                    }

                    m = (float3x3*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<float3x3>() * iterations, UnsafeUtility.AlignOf<float3x3>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        m[i] = float3x3.identity;
                    }

                }

                public void Dispose()
                {
                    UnsafeUtility.Free(forward, Allocator.Persistent);
                    UnsafeUtility.Free(up, Allocator.Persistent);
                    UnsafeUtility.Free(m, Allocator.Persistent);
                }
            }

            public static void CommonTestFunction(ref Arguments args)
            {
                for (int i = 0; i < iterations; ++i)
                {
                    args.m[i] = float3x3.LookRotation(args.forward[i], args.up[i]);
                }
            }

            public static void MonoTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            [BurstCompile(CompileSynchronously = true)]
            public static void BurstTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            public delegate void TestFunction(ref Arguments args);
        }

        [Test, Performance]
        public void float3x3_LookRotation_mono()
        {
            float3x3_LookRotation.TestFunction testFunction = float3x3_LookRotation.MonoTestFunction;
            var args = new float3x3_LookRotation.Arguments();
            args.Init();

            var monoSampleGroup = new SampleGroup("Mono", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(monoSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }

        [Test, Performance]
        public void float3x3_LookRotation_burst()
        {
            FunctionPointer<float3x3_LookRotation.TestFunction> testFunction = BurstCompiler.CompileFunctionPointer<float3x3_LookRotation.TestFunction>(float3x3_LookRotation.BurstTestFunction);
            var args = new float3x3_LookRotation.Arguments();
            args.Init();

            var burstSampleGroup = new SampleGroup("Burst", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(burstSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }
        [BurstCompile(CompileSynchronously = true)]
        public unsafe class float3x3_LookRotationSafe
        {
            public const int iterations = 10000;

            public struct Arguments : IDisposable
            {
                public Random rng;
                public float3* forward;
                public float3* up;
                public float3x3* m;

                public void Init()
                {
                    rng = new Random(1);
                    forward = (float3*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<float3>() * iterations, UnsafeUtility.AlignOf<float3>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        forward[i] = math.normalize(new float3(1.0f));
                    }

                    up = (float3*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<float3>() * iterations, UnsafeUtility.AlignOf<float3>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        up[i] = math.normalize(new float3(0.0f, 1.0f, 0.0f));
                    }

                    m = (float3x3*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<float3x3>() * iterations, UnsafeUtility.AlignOf<float3x3>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        m[i] = float3x3.identity;
                    }

                }

                public void Dispose()
                {
                    UnsafeUtility.Free(forward, Allocator.Persistent);
                    UnsafeUtility.Free(up, Allocator.Persistent);
                    UnsafeUtility.Free(m, Allocator.Persistent);
                }
            }

            public static void CommonTestFunction(ref Arguments args)
            {
                for (int i = 0; i < iterations; ++i)
                {
                    args.m[i] = float3x3.LookRotationSafe(args.forward[i], args.up[i]);
                }
            }

            public static void MonoTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            [BurstCompile(CompileSynchronously = true)]
            public static void BurstTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            public delegate void TestFunction(ref Arguments args);
        }

        [Test, Performance]
        public void float3x3_LookRotationSafe_mono()
        {
            float3x3_LookRotationSafe.TestFunction testFunction = float3x3_LookRotationSafe.MonoTestFunction;
            var args = new float3x3_LookRotationSafe.Arguments();
            args.Init();

            var monoSampleGroup = new SampleGroup("Mono", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(monoSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }

        [Test, Performance]
        public void float3x3_LookRotationSafe_burst()
        {
            FunctionPointer<float3x3_LookRotationSafe.TestFunction> testFunction = BurstCompiler.CompileFunctionPointer<float3x3_LookRotationSafe.TestFunction>(float3x3_LookRotationSafe.BurstTestFunction);
            var args = new float3x3_LookRotationSafe.Arguments();
            args.Init();

            var burstSampleGroup = new SampleGroup("Burst", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(burstSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }
        [BurstCompile(CompileSynchronously = true)]
        public unsafe class float4x4_LookAt
        {
            public const int iterations = 10000;

            public struct Arguments : IDisposable
            {
                public Random rng;
                public float3* eye;
                public float3* target;
                public float3* up;
                public float4x4* m;

                public void Init()
                {
                    rng = new Random(1);
                    eye = (float3*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<float3>() * iterations, UnsafeUtility.AlignOf<float3>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        eye[i] = math.normalize(new float3(1.0f));
                    }

                    target = (float3*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<float3>() * iterations, UnsafeUtility.AlignOf<float3>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        target[i] = math.normalize(new float3(0.0f, 1.0f, 0.0f));
                    }

                    up = (float3*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<float3>() * iterations, UnsafeUtility.AlignOf<float3>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        up[i] = math.normalize(new float3(-5.0f, 2.0f, 3.0f));
                    }

                    m = (float4x4*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<float4x4>() * iterations, UnsafeUtility.AlignOf<float4x4>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        m[i] = float4x4.identity;
                    }

                }

                public void Dispose()
                {
                    UnsafeUtility.Free(eye, Allocator.Persistent);
                    UnsafeUtility.Free(target, Allocator.Persistent);
                    UnsafeUtility.Free(up, Allocator.Persistent);
                    UnsafeUtility.Free(m, Allocator.Persistent);
                }
            }

            public static void CommonTestFunction(ref Arguments args)
            {
                for (int i = 0; i < iterations; ++i)
                {
                    args.m[i] = float4x4.LookAt(args.eye[i], args.target[i], args.up[i]);
                }
            }

            public static void MonoTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            [BurstCompile(CompileSynchronously = true)]
            public static void BurstTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            public delegate void TestFunction(ref Arguments args);
        }

        [Test, Performance]
        public void float4x4_LookAt_mono()
        {
            float4x4_LookAt.TestFunction testFunction = float4x4_LookAt.MonoTestFunction;
            var args = new float4x4_LookAt.Arguments();
            args.Init();

            var monoSampleGroup = new SampleGroup("Mono", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(monoSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }

        [Test, Performance]
        public void float4x4_LookAt_burst()
        {
            FunctionPointer<float4x4_LookAt.TestFunction> testFunction = BurstCompiler.CompileFunctionPointer<float4x4_LookAt.TestFunction>(float4x4_LookAt.BurstTestFunction);
            var args = new float4x4_LookAt.Arguments();
            args.Init();

            var burstSampleGroup = new SampleGroup("Burst", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(burstSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }
    }
}
