//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated. To update the generation of this file, modify and re-run Unity.Mathematics.CodeGen.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using NUnit.Framework;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.PerformanceTesting;
using Unity.Mathematics.Geometry;
using Unity.Burst;

namespace Unity.Mathematics.PerformanceTests
{
    partial class TestHash
    {
        [BurstCompile(CompileSynchronously = true)]
        public unsafe class float2_hash
        {
            public const int iterations = 100000;

            public struct Arguments : IDisposable
            {
                public Random rng;
                public float2* v;
                public uint* hash;

                public void Init()
                {
                    rng = new Random(1);
                    v = (float2*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<float2>() * iterations, UnsafeUtility.AlignOf<float2>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        v[i] = new float2(1.0f);
                    }

                    hash = (uint*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<uint>() * iterations, UnsafeUtility.AlignOf<uint>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        hash[i] = 0;
                    }

                }

                public void Dispose()
                {
                    UnsafeUtility.Free(v, Allocator.Persistent);
                    UnsafeUtility.Free(hash, Allocator.Persistent);
                }
            }

            public static void CommonTestFunction(ref Arguments args)
            {
                for (int i = 0; i < iterations; ++i)
                {
                    args.hash[i] = math.hash(args.v[i]);
                }
            }

            public static void MonoTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            [BurstCompile(CompileSynchronously = true)]
            public static void BurstTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            public delegate void TestFunction(ref Arguments args);
        }

        [Test, Performance]
        public void float2_hash_mono()
        {
            float2_hash.TestFunction testFunction = float2_hash.MonoTestFunction;
            var args = new float2_hash.Arguments();
            args.Init();

            var monoSampleGroup = new SampleGroup("Mono", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(monoSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }

        [Test, Performance]
        public void float2_hash_burst()
        {
            FunctionPointer<float2_hash.TestFunction> testFunction = BurstCompiler.CompileFunctionPointer<float2_hash.TestFunction>(float2_hash.BurstTestFunction);
            var args = new float2_hash.Arguments();
            args.Init();

            var burstSampleGroup = new SampleGroup("Burst", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(burstSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }
        [BurstCompile(CompileSynchronously = true)]
        public unsafe class float3_hash
        {
            public const int iterations = 100000;

            public struct Arguments : IDisposable
            {
                public Random rng;
                public float3* v;
                public uint* hash;

                public void Init()
                {
                    rng = new Random(1);
                    v = (float3*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<float3>() * iterations, UnsafeUtility.AlignOf<float3>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        v[i] = new float3(1.0f);
                    }

                    hash = (uint*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<uint>() * iterations, UnsafeUtility.AlignOf<uint>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        hash[i] = 0;
                    }

                }

                public void Dispose()
                {
                    UnsafeUtility.Free(v, Allocator.Persistent);
                    UnsafeUtility.Free(hash, Allocator.Persistent);
                }
            }

            public static void CommonTestFunction(ref Arguments args)
            {
                for (int i = 0; i < iterations; ++i)
                {
                    args.hash[i] = math.hash(args.v[i]);
                }
            }

            public static void MonoTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            [BurstCompile(CompileSynchronously = true)]
            public static void BurstTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            public delegate void TestFunction(ref Arguments args);
        }

        [Test, Performance]
        public void float3_hash_mono()
        {
            float3_hash.TestFunction testFunction = float3_hash.MonoTestFunction;
            var args = new float3_hash.Arguments();
            args.Init();

            var monoSampleGroup = new SampleGroup("Mono", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(monoSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }

        [Test, Performance]
        public void float3_hash_burst()
        {
            FunctionPointer<float3_hash.TestFunction> testFunction = BurstCompiler.CompileFunctionPointer<float3_hash.TestFunction>(float3_hash.BurstTestFunction);
            var args = new float3_hash.Arguments();
            args.Init();

            var burstSampleGroup = new SampleGroup("Burst", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(burstSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }
        [BurstCompile(CompileSynchronously = true)]
        public unsafe class float4_hash
        {
            public const int iterations = 100000;

            public struct Arguments : IDisposable
            {
                public Random rng;
                public float4* v;
                public uint* hash;

                public void Init()
                {
                    rng = new Random(1);
                    v = (float4*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<float4>() * iterations, UnsafeUtility.AlignOf<float4>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        v[i] = new float4(1.0f);
                    }

                    hash = (uint*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<uint>() * iterations, UnsafeUtility.AlignOf<uint>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        hash[i] = 0;
                    }

                }

                public void Dispose()
                {
                    UnsafeUtility.Free(v, Allocator.Persistent);
                    UnsafeUtility.Free(hash, Allocator.Persistent);
                }
            }

            public static void CommonTestFunction(ref Arguments args)
            {
                for (int i = 0; i < iterations; ++i)
                {
                    args.hash[i] = math.hash(args.v[i]);
                }
            }

            public static void MonoTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            [BurstCompile(CompileSynchronously = true)]
            public static void BurstTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            public delegate void TestFunction(ref Arguments args);
        }

        [Test, Performance]
        public void float4_hash_mono()
        {
            float4_hash.TestFunction testFunction = float4_hash.MonoTestFunction;
            var args = new float4_hash.Arguments();
            args.Init();

            var monoSampleGroup = new SampleGroup("Mono", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(monoSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }

        [Test, Performance]
        public void float4_hash_burst()
        {
            FunctionPointer<float4_hash.TestFunction> testFunction = BurstCompiler.CompileFunctionPointer<float4_hash.TestFunction>(float4_hash.BurstTestFunction);
            var args = new float4_hash.Arguments();
            args.Init();

            var burstSampleGroup = new SampleGroup("Burst", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(burstSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }
        [BurstCompile(CompileSynchronously = true)]
        public unsafe class double2_hash
        {
            public const int iterations = 100000;

            public struct Arguments : IDisposable
            {
                public Random rng;
                public double2* v;
                public uint* hash;

                public void Init()
                {
                    rng = new Random(1);
                    v = (double2*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<double2>() * iterations, UnsafeUtility.AlignOf<double2>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        v[i] = new double2(1.0f);
                    }

                    hash = (uint*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<uint>() * iterations, UnsafeUtility.AlignOf<uint>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        hash[i] = 0;
                    }

                }

                public void Dispose()
                {
                    UnsafeUtility.Free(v, Allocator.Persistent);
                    UnsafeUtility.Free(hash, Allocator.Persistent);
                }
            }

            public static void CommonTestFunction(ref Arguments args)
            {
                for (int i = 0; i < iterations; ++i)
                {
                    args.hash[i] = math.hash(args.v[i]);
                }
            }

            public static void MonoTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            [BurstCompile(CompileSynchronously = true)]
            public static void BurstTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            public delegate void TestFunction(ref Arguments args);
        }

        [Test, Performance]
        public void double2_hash_mono()
        {
            double2_hash.TestFunction testFunction = double2_hash.MonoTestFunction;
            var args = new double2_hash.Arguments();
            args.Init();

            var monoSampleGroup = new SampleGroup("Mono", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(monoSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }

        [Test, Performance]
        public void double2_hash_burst()
        {
            FunctionPointer<double2_hash.TestFunction> testFunction = BurstCompiler.CompileFunctionPointer<double2_hash.TestFunction>(double2_hash.BurstTestFunction);
            var args = new double2_hash.Arguments();
            args.Init();

            var burstSampleGroup = new SampleGroup("Burst", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(burstSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }
        [BurstCompile(CompileSynchronously = true)]
        public unsafe class double3_hash
        {
            public const int iterations = 100000;

            public struct Arguments : IDisposable
            {
                public Random rng;
                public double3* v;
                public uint* hash;

                public void Init()
                {
                    rng = new Random(1);
                    v = (double3*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<double3>() * iterations, UnsafeUtility.AlignOf<double3>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        v[i] = new double3(1.0f);
                    }

                    hash = (uint*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<uint>() * iterations, UnsafeUtility.AlignOf<uint>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        hash[i] = 0;
                    }

                }

                public void Dispose()
                {
                    UnsafeUtility.Free(v, Allocator.Persistent);
                    UnsafeUtility.Free(hash, Allocator.Persistent);
                }
            }

            public static void CommonTestFunction(ref Arguments args)
            {
                for (int i = 0; i < iterations; ++i)
                {
                    args.hash[i] = math.hash(args.v[i]);
                }
            }

            public static void MonoTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            [BurstCompile(CompileSynchronously = true)]
            public static void BurstTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            public delegate void TestFunction(ref Arguments args);
        }

        [Test, Performance]
        public void double3_hash_mono()
        {
            double3_hash.TestFunction testFunction = double3_hash.MonoTestFunction;
            var args = new double3_hash.Arguments();
            args.Init();

            var monoSampleGroup = new SampleGroup("Mono", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(monoSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }

        [Test, Performance]
        public void double3_hash_burst()
        {
            FunctionPointer<double3_hash.TestFunction> testFunction = BurstCompiler.CompileFunctionPointer<double3_hash.TestFunction>(double3_hash.BurstTestFunction);
            var args = new double3_hash.Arguments();
            args.Init();

            var burstSampleGroup = new SampleGroup("Burst", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(burstSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }
        [BurstCompile(CompileSynchronously = true)]
        public unsafe class double4_hash
        {
            public const int iterations = 100000;

            public struct Arguments : IDisposable
            {
                public Random rng;
                public double4* v;
                public uint* hash;

                public void Init()
                {
                    rng = new Random(1);
                    v = (double4*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<double4>() * iterations, UnsafeUtility.AlignOf<double4>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        v[i] = new double4(1.0f);
                    }

                    hash = (uint*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<uint>() * iterations, UnsafeUtility.AlignOf<uint>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        hash[i] = 0;
                    }

                }

                public void Dispose()
                {
                    UnsafeUtility.Free(v, Allocator.Persistent);
                    UnsafeUtility.Free(hash, Allocator.Persistent);
                }
            }

            public static void CommonTestFunction(ref Arguments args)
            {
                for (int i = 0; i < iterations; ++i)
                {
                    args.hash[i] = math.hash(args.v[i]);
                }
            }

            public static void MonoTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            [BurstCompile(CompileSynchronously = true)]
            public static void BurstTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            public delegate void TestFunction(ref Arguments args);
        }

        [Test, Performance]
        public void double4_hash_mono()
        {
            double4_hash.TestFunction testFunction = double4_hash.MonoTestFunction;
            var args = new double4_hash.Arguments();
            args.Init();

            var monoSampleGroup = new SampleGroup("Mono", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(monoSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }

        [Test, Performance]
        public void double4_hash_burst()
        {
            FunctionPointer<double4_hash.TestFunction> testFunction = BurstCompiler.CompileFunctionPointer<double4_hash.TestFunction>(double4_hash.BurstTestFunction);
            var args = new double4_hash.Arguments();
            args.Init();

            var burstSampleGroup = new SampleGroup("Burst", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(burstSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }
        [BurstCompile(CompileSynchronously = true)]
        public unsafe class float2x2_hash
        {
            public const int iterations = 100000;

            public struct Arguments : IDisposable
            {
                public Random rng;
                public float2x2* v;
                public uint* hash;

                public void Init()
                {
                    rng = new Random(1);
                    v = (float2x2*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<float2x2>() * iterations, UnsafeUtility.AlignOf<float2x2>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        v[i] = new float2x2(1.0f);
                    }

                    hash = (uint*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<uint>() * iterations, UnsafeUtility.AlignOf<uint>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        hash[i] = 0;
                    }

                }

                public void Dispose()
                {
                    UnsafeUtility.Free(v, Allocator.Persistent);
                    UnsafeUtility.Free(hash, Allocator.Persistent);
                }
            }

            public static void CommonTestFunction(ref Arguments args)
            {
                for (int i = 0; i < iterations; ++i)
                {
                    args.hash[i] = math.hash(args.v[i]);
                }
            }

            public static void MonoTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            [BurstCompile(CompileSynchronously = true)]
            public static void BurstTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            public delegate void TestFunction(ref Arguments args);
        }

        [Test, Performance]
        public void float2x2_hash_mono()
        {
            float2x2_hash.TestFunction testFunction = float2x2_hash.MonoTestFunction;
            var args = new float2x2_hash.Arguments();
            args.Init();

            var monoSampleGroup = new SampleGroup("Mono", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(monoSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }

        [Test, Performance]
        public void float2x2_hash_burst()
        {
            FunctionPointer<float2x2_hash.TestFunction> testFunction = BurstCompiler.CompileFunctionPointer<float2x2_hash.TestFunction>(float2x2_hash.BurstTestFunction);
            var args = new float2x2_hash.Arguments();
            args.Init();

            var burstSampleGroup = new SampleGroup("Burst", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(burstSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }
        [BurstCompile(CompileSynchronously = true)]
        public unsafe class float3x3_hash
        {
            public const int iterations = 100000;

            public struct Arguments : IDisposable
            {
                public Random rng;
                public float3x3* v;
                public uint* hash;

                public void Init()
                {
                    rng = new Random(1);
                    v = (float3x3*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<float3x3>() * iterations, UnsafeUtility.AlignOf<float3x3>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        v[i] = new float3x3(1.0f);
                    }

                    hash = (uint*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<uint>() * iterations, UnsafeUtility.AlignOf<uint>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        hash[i] = 0;
                    }

                }

                public void Dispose()
                {
                    UnsafeUtility.Free(v, Allocator.Persistent);
                    UnsafeUtility.Free(hash, Allocator.Persistent);
                }
            }

            public static void CommonTestFunction(ref Arguments args)
            {
                for (int i = 0; i < iterations; ++i)
                {
                    args.hash[i] = math.hash(args.v[i]);
                }
            }

            public static void MonoTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            [BurstCompile(CompileSynchronously = true)]
            public static void BurstTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            public delegate void TestFunction(ref Arguments args);
        }

        [Test, Performance]
        public void float3x3_hash_mono()
        {
            float3x3_hash.TestFunction testFunction = float3x3_hash.MonoTestFunction;
            var args = new float3x3_hash.Arguments();
            args.Init();

            var monoSampleGroup = new SampleGroup("Mono", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(monoSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }

        [Test, Performance]
        public void float3x3_hash_burst()
        {
            FunctionPointer<float3x3_hash.TestFunction> testFunction = BurstCompiler.CompileFunctionPointer<float3x3_hash.TestFunction>(float3x3_hash.BurstTestFunction);
            var args = new float3x3_hash.Arguments();
            args.Init();

            var burstSampleGroup = new SampleGroup("Burst", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(burstSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }
        [BurstCompile(CompileSynchronously = true)]
        public unsafe class float4x4_hash
        {
            public const int iterations = 100000;

            public struct Arguments : IDisposable
            {
                public Random rng;
                public float4x4* v;
                public uint* hash;

                public void Init()
                {
                    rng = new Random(1);
                    v = (float4x4*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<float4x4>() * iterations, UnsafeUtility.AlignOf<float4x4>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        v[i] = new float4x4(1.0f);
                    }

                    hash = (uint*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<uint>() * iterations, UnsafeUtility.AlignOf<uint>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        hash[i] = 0;
                    }

                }

                public void Dispose()
                {
                    UnsafeUtility.Free(v, Allocator.Persistent);
                    UnsafeUtility.Free(hash, Allocator.Persistent);
                }
            }

            public static void CommonTestFunction(ref Arguments args)
            {
                for (int i = 0; i < iterations; ++i)
                {
                    args.hash[i] = math.hash(args.v[i]);
                }
            }

            public static void MonoTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            [BurstCompile(CompileSynchronously = true)]
            public static void BurstTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            public delegate void TestFunction(ref Arguments args);
        }

        [Test, Performance]
        public void float4x4_hash_mono()
        {
            float4x4_hash.TestFunction testFunction = float4x4_hash.MonoTestFunction;
            var args = new float4x4_hash.Arguments();
            args.Init();

            var monoSampleGroup = new SampleGroup("Mono", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(monoSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }

        [Test, Performance]
        public void float4x4_hash_burst()
        {
            FunctionPointer<float4x4_hash.TestFunction> testFunction = BurstCompiler.CompileFunctionPointer<float4x4_hash.TestFunction>(float4x4_hash.BurstTestFunction);
            var args = new float4x4_hash.Arguments();
            args.Init();

            var burstSampleGroup = new SampleGroup("Burst", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(burstSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }
        [BurstCompile(CompileSynchronously = true)]
        public unsafe class float2x2_hashwide
        {
            public const int iterations = 100000;

            public struct Arguments : IDisposable
            {
                public Random rng;
                public float2x2* v;
                public uint2* hash;

                public void Init()
                {
                    rng = new Random(1);
                    v = (float2x2*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<float2x2>() * iterations, UnsafeUtility.AlignOf<float2x2>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        v[i] = new float2x2(1.0f);
                    }

                    hash = (uint2*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<uint2>() * iterations, UnsafeUtility.AlignOf<uint2>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        hash[i] = 0;
                    }

                }

                public void Dispose()
                {
                    UnsafeUtility.Free(v, Allocator.Persistent);
                    UnsafeUtility.Free(hash, Allocator.Persistent);
                }
            }

            public static void CommonTestFunction(ref Arguments args)
            {
                for (int i = 0; i < iterations; ++i)
                {
                    args.hash[i] = math.hashwide(args.v[i]);
                }
            }

            public static void MonoTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            [BurstCompile(CompileSynchronously = true)]
            public static void BurstTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            public delegate void TestFunction(ref Arguments args);
        }

        [Test, Performance]
        public void float2x2_hashwide_mono()
        {
            float2x2_hashwide.TestFunction testFunction = float2x2_hashwide.MonoTestFunction;
            var args = new float2x2_hashwide.Arguments();
            args.Init();

            var monoSampleGroup = new SampleGroup("Mono", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(monoSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }

        [Test, Performance]
        public void float2x2_hashwide_burst()
        {
            FunctionPointer<float2x2_hashwide.TestFunction> testFunction = BurstCompiler.CompileFunctionPointer<float2x2_hashwide.TestFunction>(float2x2_hashwide.BurstTestFunction);
            var args = new float2x2_hashwide.Arguments();
            args.Init();

            var burstSampleGroup = new SampleGroup("Burst", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(burstSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }
        [BurstCompile(CompileSynchronously = true)]
        public unsafe class float3x3_hashwide
        {
            public const int iterations = 100000;

            public struct Arguments : IDisposable
            {
                public Random rng;
                public float3x3* v;
                public uint3* hash;

                public void Init()
                {
                    rng = new Random(1);
                    v = (float3x3*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<float3x3>() * iterations, UnsafeUtility.AlignOf<float3x3>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        v[i] = new float3x3(1.0f);
                    }

                    hash = (uint3*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<uint3>() * iterations, UnsafeUtility.AlignOf<uint3>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        hash[i] = 0;
                    }

                }

                public void Dispose()
                {
                    UnsafeUtility.Free(v, Allocator.Persistent);
                    UnsafeUtility.Free(hash, Allocator.Persistent);
                }
            }

            public static void CommonTestFunction(ref Arguments args)
            {
                for (int i = 0; i < iterations; ++i)
                {
                    args.hash[i] = math.hashwide(args.v[i]);
                }
            }

            public static void MonoTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            [BurstCompile(CompileSynchronously = true)]
            public static void BurstTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            public delegate void TestFunction(ref Arguments args);
        }

        [Test, Performance]
        public void float3x3_hashwide_mono()
        {
            float3x3_hashwide.TestFunction testFunction = float3x3_hashwide.MonoTestFunction;
            var args = new float3x3_hashwide.Arguments();
            args.Init();

            var monoSampleGroup = new SampleGroup("Mono", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(monoSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }

        [Test, Performance]
        public void float3x3_hashwide_burst()
        {
            FunctionPointer<float3x3_hashwide.TestFunction> testFunction = BurstCompiler.CompileFunctionPointer<float3x3_hashwide.TestFunction>(float3x3_hashwide.BurstTestFunction);
            var args = new float3x3_hashwide.Arguments();
            args.Init();

            var burstSampleGroup = new SampleGroup("Burst", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(burstSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }
        [BurstCompile(CompileSynchronously = true)]
        public unsafe class float4x4_hashwide
        {
            public const int iterations = 100000;

            public struct Arguments : IDisposable
            {
                public Random rng;
                public float4x4* v;
                public uint4* hash;

                public void Init()
                {
                    rng = new Random(1);
                    v = (float4x4*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<float4x4>() * iterations, UnsafeUtility.AlignOf<float4x4>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        v[i] = new float4x4(1.0f);
                    }

                    hash = (uint4*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<uint4>() * iterations, UnsafeUtility.AlignOf<uint4>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        hash[i] = 0;
                    }

                }

                public void Dispose()
                {
                    UnsafeUtility.Free(v, Allocator.Persistent);
                    UnsafeUtility.Free(hash, Allocator.Persistent);
                }
            }

            public static void CommonTestFunction(ref Arguments args)
            {
                for (int i = 0; i < iterations; ++i)
                {
                    args.hash[i] = math.hashwide(args.v[i]);
                }
            }

            public static void MonoTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            [BurstCompile(CompileSynchronously = true)]
            public static void BurstTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            public delegate void TestFunction(ref Arguments args);
        }

        [Test, Performance]
        public void float4x4_hashwide_mono()
        {
            float4x4_hashwide.TestFunction testFunction = float4x4_hashwide.MonoTestFunction;
            var args = new float4x4_hashwide.Arguments();
            args.Init();

            var monoSampleGroup = new SampleGroup("Mono", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(monoSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }

        [Test, Performance]
        public void float4x4_hashwide_burst()
        {
            FunctionPointer<float4x4_hashwide.TestFunction> testFunction = BurstCompiler.CompileFunctionPointer<float4x4_hashwide.TestFunction>(float4x4_hashwide.BurstTestFunction);
            var args = new float4x4_hashwide.Arguments();
            args.Init();

            var burstSampleGroup = new SampleGroup("Burst", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(burstSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }
        [BurstCompile(CompileSynchronously = true)]
        public unsafe class float2_hashwide
        {
            public const int iterations = 100000;

            public struct Arguments : IDisposable
            {
                public Random rng;
                public float2* v;
                public uint2* hash;

                public void Init()
                {
                    rng = new Random(1);
                    v = (float2*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<float2>() * iterations, UnsafeUtility.AlignOf<float2>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        v[i] = new float2(1.0f);
                    }

                    hash = (uint2*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<uint2>() * iterations, UnsafeUtility.AlignOf<uint2>(), Allocator.Persistent);
                    for (int i = 0; i < iterations; ++i)
                    {
                        hash[i] = new uint2();
                    }

                }

                public void Dispose()
                {
                    UnsafeUtility.Free(v, Allocator.Persistent);
                    UnsafeUtility.Free(hash, Allocator.Persistent);
                }
            }

            public static void CommonTestFunction(ref Arguments args)
            {
                for (int i = 0; i < iterations; ++i)
                {
                    args.hash[i] = math.hashwide(args.v[i]);
                }
            }

            public static void MonoTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            [BurstCompile(CompileSynchronously = true)]
            public static void BurstTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            public delegate void TestFunction(ref Arguments args);
        }

        [Test, Performance]
        public void float2_hashwide_mono()
        {
            float2_hashwide.TestFunction testFunction = float2_hashwide.MonoTestFunction;
            var args = new float2_hashwide.Arguments();
            args.Init();

            var monoSampleGroup = new SampleGroup("Mono", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(monoSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }

        [Test, Performance]
        public void float2_hashwide_burst()
        {
            FunctionPointer<float2_hashwide.TestFunction> testFunction = BurstCompiler.CompileFunctionPointer<float2_hashwide.TestFunction>(float2_hashwide.BurstTestFunction);
            var args = new float2_hashwide.Arguments();
            args.Init();

            var burstSampleGroup = new SampleGroup("Burst", SampleUnit.Microsecond);            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .SampleGroup(burstSampleGroup)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }
    }
}
